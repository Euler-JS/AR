<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>AR Simples - Funcional</title>
    
    <!-- A-Frame vers√£o est√°vel -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    
    <!-- AR.js vers√£o mais recente e est√°vel -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>
    
    <script>
        // Registrar componente gesture-detector ANTES da cena
        AFRAME.registerComponent('gesture-detector', {
            schema: {
                element: { default: '' }
            },
            init: function() {
                this.targetElement = this.data.element || this.el;
                this.internalState = {
                    previousState: null
                };
                this.emitGestureEvent = this.emitGestureEvent.bind(this);
                this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.addEventListener('touchend', this.emitGestureEvent);
                this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
            },
            remove: function() {
                this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
            },
            emitGestureEvent: function(event) {
                const currentState = this.getTouchState(event);
                const previousState = this.internalState.previousState;

                const gestureContinues = previousState &&
                    currentState &&
                    currentState.touchCount == previousState.touchCount;

                const gestureEnded = previousState && !gestureContinues;
                const gestureStarted = currentState && !gestureContinues;

                if (gestureEnded) {
                    const eventName = this.getEventPrefix(previousState.touchCount) + 'fingerend';
                    this.el.emit(eventName, previousState);
                    this.internalState.previousState = null;
                }

                if (gestureStarted) {
                    currentState.startTime = performance.now();
                    currentState.startPosition = currentState.position;
                    currentState.startSpread = currentState.spread;
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'fingerstart';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }

                if (gestureContinues) {
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'fingermove';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }
            },
            getTouchState: function(event) {
                if (event.touches.length === 0) {
                    return null;
                }

                const touchList = [];
                for (let i = 0; i < event.touches.length; i++) {
                    touchList.push(event.touches[i]);
                }

                const touchCount = touchList.length;
                const centroid = this.getCentroid(touchList);
                const spread = this.getSpread(touchList, centroid);

                return {
                    touchCount: touchCount,
                    position: centroid,
                    spread: spread,
                    touches: touchList
                };
            },
            getCentroid: function(touchList) {
                let x = 0;
                let y = 0;
                for (let i = 0; i < touchList.length; i++) {
                    x += touchList[i].clientX;
                    y += touchList[i].clientY;
                }
                x /= touchList.length;
                y /= touchList.length;
                return { x: x, y: y };
            },
            getSpread: function(touchList, centroid) {
                let spread = 0;
                for (let i = 0; i < touchList.length; i++) {
                    spread += Math.sqrt(
                        Math.pow(centroid.x - touchList[i].clientX, 2) +
                        Math.pow(centroid.y - touchList[i].clientY, 2));
                }
                spread /= touchList.length;
                return spread;
            },
            getEventPrefix: function(touchCount) {
                const numberNames = ['zero', 'one', 'two', 'three', 'four', 'five'];
                return numberNames[touchCount];
            }
        });
    </script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            z-index: 999;
            font-size: 12px;
            max-width: 200px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 999;
        }
        .debug-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <p>üîÑ Carregando AR...</p>
        <p>Verificando c√¢mera...</p>
    </div>
    
    <div id="info">
        üéØ Aponte para o marcador Hiro
    </div>
    
    <div id="debug">
        <button class="debug-btn" onclick="testCamera()">üé• Testar C√¢mera</button>
        <button class="debug-btn" onclick="forceStartCamera()">üîÑ For√ßar AR</button>
        <button class="debug-btn" onclick="window.location.reload()">üîÑ Recarregar</button>
    </div>

    <a-scene
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true"
        arjs="sourceType: webcam; debugUIEnabled: false;"
        embedded
        gesture-detector
        id="scene"
    >
        <!-- Marcador Hiro -->
        <a-marker preset="hiro" id="hiro-marker">
            <!-- Cubo simples -->
            <a-box
                id="box"
                position="0 0.5 0"
                rotation="0 45 0"
                scale="1 1 1"
                color="red"
                animation="property: rotation; to: 0 405 0; loop: true; dur: 5000"
            ></a-box>
            
            <!-- Texto -->
            <a-text
                value="AR OK!"
                position="0 1.5 0"
                align="center"
                color="white"
                scale="2 2 2"
            ></a-text>
        </a-marker>

        <!-- C√¢mera -->
        <a-entity camera look-controls wasd-controls="enabled: false"></a-entity>
    </a-scene>

    <script>
        // Fun√ß√£o para for√ßar inicializa√ß√£o da c√¢mera
        async function forceStartCamera() {
            console.log('For√ßando in√≠cio da c√¢mera...');
            try {
                // Tentar recriar a cena AR
                const scene = document.querySelector('a-scene');
                if (scene && scene.components && scene.components.arjs) {
                    console.log('Reiniciando AR.js...');
                    scene.components.arjs.requestWebcamPermissions();
                }
            } catch (error) {
                console.error('Erro ao for√ßar c√¢mera:', error);
            }
        }
        async function testCamera() {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            loading.innerHTML = '<p>üîç Testando acesso √† c√¢mera...</p>';
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                
                loading.innerHTML = '<p>‚úÖ C√¢mera funcionando!</p><p>Fechando teste...</p>';
                
                // Mostrar v√≠deo por 2 segundos
                setTimeout(() => {
                    stream.getTracks().forEach(track => track.stop());
                    loading.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                loading.innerHTML = `<p>‚ùå Erro: ${error.message}</p><p>Verifique permiss√µes</p>`;
            }
        }

        // Debug da c√¢mera
        async function checkCameraPermissions() {
            try {
                console.log('Verificando permiss√µes da c√¢mera...');
                
                // Verificar se getUserMedia est√° dispon√≠vel
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('getUserMedia n√£o est√° dispon√≠vel');
                    document.getElementById('loading').innerHTML = '<p>‚ùå Erro: C√¢mera n√£o suportada</p><p>Use HTTPS ou navegador compat√≠vel</p>';
                    return false;
                }

                // Tentar acessar a c√¢mera
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    } 
                });
                
                console.log('C√¢mera acessada com sucesso!');
                
                // Parar o stream de teste
                stream.getTracks().forEach(track => track.stop());
                
                document.getElementById('loading').innerHTML = '<p>‚úÖ C√¢mera OK!</p><p>Iniciando AR...</p>';
                return true;
                
            } catch (error) {
                console.error('Erro ao acessar c√¢mera:', error);
                
                let errorMsg = '';
                switch(error.name) {
                    case 'NotAllowedError':
                        errorMsg = 'Permiss√£o negada. Permita acesso √† c√¢mera.';
                        break;
                    case 'NotFoundError':
                        errorMsg = 'C√¢mera n√£o encontrada.';
                        break;
                    case 'NotSupportedError':
                        errorMsg = 'C√¢mera n√£o suportada. Use HTTPS.';
                        break;
                    default:
                        errorMsg = `Erro: ${error.message}`;
                }
                
                document.getElementById('loading').innerHTML = `<p style="color: red;">‚ùå ${errorMsg}</p><p>Clique "Testar C√¢mera" ou recarregue</p>`;
                return false;
            }
        }

        // Aguardar carregamento completo
        window.addEventListener('load', async function() {
            console.log('P√°gina carregada');
            console.log('Protocolo:', window.location.protocol);
            console.log('Hostname:', window.location.hostname);
            
            // Verificar se est√° em HTTPS ou localhost
            if (window.location.protocol !== 'https:' && 
                window.location.hostname !== 'localhost' && 
                window.location.hostname !== '127.0.0.1' &&
                window.location.hostname !== '0.0.0.0') {
                document.getElementById('loading').innerHTML = '<p style="color: red;">‚ö†Ô∏è Use HTTPS ou localhost</p><p>C√¢mera requer conex√£o segura</p>';
                return;
            }
            
            // N√£o testar c√¢mera antecipadamente - deixar AR.js gerenciar
            document.getElementById('loading').innerHTML = '<p>‚úÖ Iniciando AR...</p><p>Aguarde a c√¢mera ativar</p>';
            
            // Esconder loading ap√≥s um tempo maior
            setTimeout(() => {
                const loading = document.getElementById('loading');
                if (loading.style.display !== 'none') {
                    loading.style.display = 'none';
                }
            }, 5000);

            // Eventos do marcador
            const marker = document.querySelector('#hiro-marker');
            const info = document.getElementById('info');
            
            if (marker) {
                marker.addEventListener('markerFound', function() {
                    console.log('Marcador encontrado!');
                    info.innerHTML = '‚úÖ Marcador encontrado!';
                    info.style.background = 'rgba(0, 128, 0, 0.8)';
                });

                marker.addEventListener('markerLost', function() {
                    console.log('Marcador perdido');
                    info.innerHTML = 'üîç Procure o marcador Hiro';
                    info.style.background = 'rgba(128, 0, 0, 0.8)';
                });
            }

            // Eventos do AR.js
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.addEventListener('loaded', function() {
                    console.log('A-Scene carregada com sucesso');
                });

                scene.addEventListener('renderstart', function() {
                    console.log('Renderiza√ß√£o iniciada');
                    document.getElementById('loading').style.display = 'none';
                });
                
                // Eventos espec√≠ficos do AR.js
                scene.addEventListener('arjs-video-loaded', function() {
                    console.log('V√≠deo AR carregado!');
                    document.getElementById('info').innerHTML = 'üìπ C√¢mera funcionando - Procure marcador Hiro';
                    document.getElementById('loading').style.display = 'none';
                });

                // Mais eventos do AR.js para debug
                scene.addEventListener('camera-init', function() {
                    console.log('C√¢mera AR.js inicializada');
                });

                scene.addEventListener('camera-error', function(event) {
                    console.error('Erro na c√¢mera AR.js:', event.detail);
                    document.getElementById('loading').innerHTML = '<p style="color: red;">‚ùå Erro na c√¢mera AR</p>';
                });
            }

            // Tratamento de erros
            window.addEventListener('error', function(e) {
                console.error('Erro capturado:', e.error);
                document.getElementById('loading').innerHTML = `<p style="color: red;">‚ùå Erro: ${e.error}</p>`;
            });

            // Monitor do status da c√¢mera
            let cameraCheckCount = 0;
            const cameraMonitor = setInterval(() => {
                cameraCheckCount++;
                console.log(`Checando status AR (${cameraCheckCount}s)...`);
                
                // Verificar se tem v√≠deo elemento ativo
                const video = document.querySelector('video');
                if (video && video.srcObject) {
                    console.log('‚úÖ V√≠deo AR.js ativo!');
                    document.getElementById('info').innerHTML = 'üìπ C√¢mera ativa - Procure marcador Hiro';
                    clearInterval(cameraMonitor);
                } else if (cameraCheckCount === 5) {
                    console.log('üîÑ Tentando for√ßar in√≠cio da c√¢mera...');
                    forceStartCamera();
                } else if (cameraCheckCount > 10) {
                    console.log('‚ö†Ô∏è C√¢mera AR n√£o ativou em 10s');
                    document.getElementById('loading').innerHTML = '<p style="color: orange;">‚ö†Ô∏è C√¢mera n√£o iniciou</p><p>Clique "üîÑ For√ßar AR" ou "üé• Testar C√¢mera"</p>';
                    clearInterval(cameraMonitor);
                }
            }, 1000);
        });
    </script>
</body>
</html>